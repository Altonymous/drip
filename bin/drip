#!/usr/bin/env bash

function http_get { # Adapted from http://github.com/technomancy/leiningen
    if [[ -z $http_get ]]; then
        if type -p curl >/dev/null 2>&1; then
            http_get=curl -f -L -o
        else
            http_get=wget -O
        fi
    fi
    mkdir -p "$(dirname $1)"
    $http_get "$1.pending" "$2"
    mv -- "$1.pending" "$1"
}

function find_drip_jar {
    local script="$0"

    # Adapted from http://github.com/technomancy/leiningen
    # resolve symlinks to the script itself portably
    while [[ -h $script ]] ; do
        local ls=$(ls -ld -- "$script")
        local link=$(expr "$ls" : '.*-> \(.*\)$')
        if expr "$link" : '/.*' > /dev/null; then
            script=$link
        else
            script=$(dirname "$script"$)/$link
        fi
    done

    if [[ -z $DRIP_JAR ]]; then
        local bin_dir=$(dirname $script)
        if [[ -r $bin_dir/../src/org/flatland/drip/Main.java ]]; then
            # Checkout
            local drip_dir=$bin_dir/..
            DRIP_JAR=$drip_dir/drip.jar
            (cd -- "$drip_dir" && make -s jar)
        else
            # Standalone
            DRIP_JAR=~/.m2/repository/org/flatland/drip/$DRIP_VERSION/drip-$DRIP_VERSION.jar
            [[ -e $DRIP_JAR ]] || http_get "$DRIP_JAR" "$DRIP_URL"
        fi
    fi
}

declare -a jvm_args
declare -a main_args
declare -a runtime_args

function parse_args {
    local classpath=false
    local runtime=false

    if [[ $# -eq 0 ]]; then
        echo "Usage: drip [same args as java...]"
        exit 0
    elif [[ $# -eq 1 && $1 != *.* || $# -eq 2 && $1 == 'kill' && $2 == -* ]]; then
        drip_command=$1
        return
    fi

    for arg in "$@"; do
        if [[ -z $main_class ]]; then
            if $classpath; then
                classpath=false
            else
                if [[ $arg == "-cp" || $arg == "-classpath" ]]; then
                    classpath=true
                elif [[ $arg != -* ]]; then
                    main_class=$arg
                    continue
                fi
            fi
            jvm_args+=("$arg")
        elif $runtime; then
            runtime_args+=("$arg")
        else
            if [[ $arg == "--" ]]; then
                runtime=true
            else
                main_args+=("$arg")
            fi
        fi
    done
}

function make_sha_path {
    opts="${jvm_args[*]} $main_class"
    sha=$(echo -n "$opts" | git hash-object --stdin)
    sha_path=$DRIP_HOME/$sha
    mkdir -p "$sha_path"
    echo -n "$opts" > $sha_path/opts
}

function launch_jvm {
    jvm_dir=$sha_path/$$-$n

    if mkdir "$jvm_dir"; then
        mkfifo "$jvm_dir/in"
        mkfifo "$jvm_dir/out"
        mkfifo "$jvm_dir/err"

        java "${jvm_args[@]}" "-Xbootclasspath/a:$DRIP_JAR" \
             org.flatland.drip.Main "$main_class" "$jvm_dir" > /dev/null &
        echo $! > "$jvm_dir/jvm.pid"
    fi
}

function lock_dir {
    if mkdir "$jvm_dir/lock" 2> /dev/null; then
        if kill -0 $(cat "$jvm_dir/jvm.pid") 2> /dev/null; then
            echo $$ > "$jvm_dir/client.pid"
            active_jvm_dir=$jvm_dir
        fi
        return 0
    else
        return 1
    fi
}

function find_jvm {
    make_sha_path

    for jvm_dir in $sha_path/*-*; do
        if [[ -z $active_jvm_dir ]]; then
            lock_dir
        elif [[ ! -e $jvm_dir/lock ]]; then
            let n=$n+1
        fi
    done

    n=${n:-0}

    while [[ $n -lt $DRIP_POOL ]]; do
        let n=$n+1
        launch_jvm
    done

    if [[ -z $active_jvm_dir ]]; then
        exec java "${jvm_args[@]}" "${runtime_args[@]}" "$main_class" "${main_args[@]}"
    fi
}

function kill_jvms {
    local killed=false

    for jvm_dir in $DRIP_HOME/*/*-*; do
        if lock_dir; then
            kill "$1" "$(cat $jvm_dir/jvm.pid)" 2> /dev/null
            rm -rf "$jvm_dir"
            killed=true
        fi
    done

    $killed || echo "No idle Drip JVM running"
}

function send_array {
    local string=$*
    local length=${#string}
    [[ $length -ne 0 ]] && let length=length+1

    printf '%s:' "$length" >&3
    for e; do
        printf -- '%s\0' "$e" >&3
    done
    printf ',' >&3
}

function send_env {
    declare -a vars

    # Call declare in a bash subprocess to get rid of variables that aren't exported.
    while read -r line; do
        [[ $line == *=\(*\) ]] && continue # Filter bash arrays
        [[ $line != *=*     ]] && break    # Filter function definitions

        # Filter extra variables that were added by the bash subprocess but are not exported.
        for var in BASH BASHOPTS BASH_EXECUTION_STRING BASH_VERSION \
                   SHELLOPTS IFS PS4 UID EUID PPID; do
            [[ $line == $var=*  ]] && continue 2
        done

        vars+=("$(eval echo $line)")
    done <<< "$(bash -c declare)"

    send_array "${vars[@]}"
}

function duplex_stdin {
    exec 3> "$active_jvm_dir/in"
    send_array "${main_args[@]}"
    send_array "${runtime_args[@]}"
    send_env
    cat >&3 2> /dev/null
    exec 3>&-
}

function run_main {
    duplex_stdin <&0 &
    cat "$active_jvm_dir/err" >&2 &
    cat "$active_jvm_dir/out"
    rm -rf "$active_jvm_dir"
}

function run_drip_command {
    case $drip_command in
        version)
            echo "drip version \"$DRIP_VERSION\"" >&2
            java -version
            ;;
        kill)
            kill_jvms "$2"
            ;;
        ps)
            jps -vlm | grep org.flatland.drip.Main
            ;;
        -*)
            java $drip_command
            ;;
    esac
}

# Let's go.

DRIP_POOL=1
DRIP_HOME=${DRIP_HOME:-~/.drip} # what if this starts with a dash?
[[ -d $DRIP_HOME ]] || mkdir "$DRIP_HOME"
DRIP_VERSION=${DRIP_VERSION:-0.0.3}
DRIP_REPO=${DRIP_REPO:-http://clojars.org/repo}
DRIP_URL=${DRIP_URL:-$DRIP_REPO/org/flatland/drip/${DRIP_VERSION}/drip-${DRIP_VERSION}.jar}

find_drip_jar

parse_args "$@"

if [[ -z $drip_command ]]; then
    find_jvm
    run_main
else
    run_drip_command
fi
