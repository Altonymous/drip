#!/usr/bin/env bash

function http_get { # Adapted from http://github.com/technomancy/leiningen
    local url="$1" path="$2"

    if [[ -z $http_get ]]; then
        if type -p curl >/dev/null 2>&1; then
            http_get='curl -fL# -o'
        else
            http_get='wget -O'
        fi
    fi
    mkdir -p "$(dirname $path)"
    echo "Downloading $url..." >&2
    $http_get "$path.pending" "$url" || return 1
    mv -- "$path.pending" "$path"
}

function bootstrap {
    script="$0"

    # Adapted from http://github.com/technomancy/leiningen
    # resolve symlinks to the script itself portably
    while [[ -h $script ]] ; do
        local ls=$(ls -ld -- "$script")
        local link=$(expr "$ls" : '.*-> \(.*\)$')
        if expr "$link" : '/.*' > /dev/null; then
            script=$link
        else
            script=$(dirname "$script"$)/$link
        fi
    done

    if [[ -z $DRIP_JAR ]]; then
        local bin_dir=$(dirname $script)
        if [[ -r $bin_dir/../src/org/flatland/drip/Main.java ]]; then
            # Checkout
            drip_dir=$bin_dir/..
            DRIP_JAR=$drip_dir/drip.jar
            (cd -- "$drip_dir" && make -s jar)
        else
            # Standalone
            DRIP_JAR=$(mvn_get 'drip' 'org/flatland' "$DRIP_VERSION" "$DRIP_JAR_URL")
        fi
    fi
    drip_proxy=$(compile 'drip_proxy')
    drip_daemon=$(compile 'drip_daemon')
}

function compile {
    local base=$1
    local src_file
    local bin_file="$DRIP_HOME/$base"

    if [[ -z $drip_dir ]]; then
        mkdir -p "$DRIP_SRC"
        src_file=$DRIP_SRC/$base.c
        [[ -e $src_file ]] || http_get "$DRIP_SRC_URL/$base.c" "$src_file"
    else
        src_file=$drip_dir/src/$base.c
    fi
    if [[ $src_file -nt $bin_file ]]; then
        gcc $src_file -o $bin_file
    fi
    echo "$bin_file"
}

function mvn_get {
    local artifact="$1" group="$2" version="$3" url="$4"
    local jar="$MVN_REPO/$group/$artifact/$version/$artifact-$version.jar"
    [[ -e $jar ]] || http_get "$url" "$jar"
    printf '%s' "$jar"
}

declare -a jvm_args
declare -a main_args
declare -a runtime_args

function parse_args {
    if [[ $# -eq 0 ]]; then
        echo 'Usage: drip [command | same args as java]'
        echo
        echo 'drip supports the following commands:'
        echo '    version          print drip version and exit'
        echo '    upgrade          upgrade drip to the latest version'
        echo '    kill [-signal]   kill all idle drip JVMs (with signal)'
        echo '    ps               print a list of all drip processes'
        exit 0
    elif ! expr "$1" : '.*[.-]' > /dev/null; then
        drip_command=$1
        return
    elif [[ $# -eq 1 && $1 == -* ]]; then
        java_command=$1
        return
    fi

    local classpath=false
    for arg in "$@"; do
        if [[ -z $main_class ]]; then
            if $classpath; then
                classpath=false
            elif [[ $arg == "-cp" || $arg == "-classpath" ]]; then
                classpath=true
            elif [[ $arg == --* ]]; then
                runtime_args+=("${arg:1}")
                continue
            elif [[ $arg != -* ]]; then
                main_class=$arg
                continue
            fi
            jvm_args+=("$arg")
        else
            main_args+=("$arg")
        fi
    done
}

function make_sha_path {
    opts="${jvm_args[*]} $main_class"
    sha=$(echo -n "$opts" | git hash-object --stdin)
    sha_path=$DRIP_HOME/$DRIP_VERSION/$sha
    mkdir -p "$sha_path"
    echo -n "$opts" > $sha_path/opts
}

function default_init_args {
    local f='%s\n%s'
    case ${DRIP_INIT_CLASS:-$main_class} in
        clojure.main)                      printf $f '-e' 'nil';;
        org.jruby.Main)                    printf $f '-e' 'nil';;
        scala.tools.nsc.MainGenericRunner) printf $f '-e' 'null';;
    esac
}

function launch_jvm {
    jvm_dir=$sha_path/$$-$n

    if mkdir "$jvm_dir"; then
        mkfifo "$jvm_dir/control"
        mkfifo "$jvm_dir/status"
        mkfifo "$jvm_dir/tty"

        export DRIP_INIT=${DRIP_INIT:-$(default_init_args)}

        $drip_daemon $JAVA_CMD "${jvm_args[@]}" -Djava.awt.headless=true \
                               "-Xbootclasspath/a:$DRIP_JAR" \
                               org.flatland.drip.Main "$main_class" "$jvm_dir" > /dev/null
    fi
}

function lock_dir {
    if mkdir "$jvm_dir/lock" 2> /dev/null; then
        if kill -0 $(cat "$jvm_dir/jvm.pid") 2> /dev/null; then
            echo $$ > "$jvm_dir/client.pid"
            active_jvm_dir=$jvm_dir
        fi
        return 0
    else
        return 1
    fi
}

function find_jvm {
    make_sha_path

    for jvm_dir in $sha_path/*-*; do
        if [[ -z $active_jvm_dir ]]; then
            lock_dir
        elif [[ ! -e $jvm_dir/lock ]]; then
            let n=$n+1
        fi
    done

    n=${n:-0}

    while (( $n < $DRIP_POOL )); do
        let n=$n+1
        launch_jvm
    done

    if [[ -z $active_jvm_dir ]]; then
        exec $JAVA_CMD "${jvm_args[@]}" "${runtime_args[@]}" "$main_class" "${main_args[@]}"
    fi
}

function kill_jvms {
    local killed=false

    for jvm_dir in $DRIP_HOME/*/*/*-*; do
        if lock_dir; then
            kill "$1" "$(cat $jvm_dir/jvm.pid)" 2> /dev/null
            rm -rf "$jvm_dir"
            killed=true
        fi
    done

    $killed || echo "No idle Drip JVM running"
}

function send_array {
    local string=$*
    local length=${#string}
    (( $length != 0 )) && let length=length+1

    printf '%s:' "$length"
    for e; do
        printf -- '%s\0' "$e"
    done
    printf ','
}

function send_env {
    declare -a vars

    # Call declare in a bash subprocess to get rid of variables that aren't exported.
    while read -r line; do
        [[ $line == *=\(*\) ]] && continue # Filter bash arrays
        [[ $line != *=*     ]] && break    # Filter function definitions

        # Filter extra variables that were added by the bash subprocess but are not exported.
        for var in BASH BASHOPTS BASH_EXECUTION_STRING BASH_VERSION \
                   SHELLOPTS IFS PS4 UID EUID PPID; do
            [[ $line == $var=*  ]] && continue 2
        done

        vars+=("$(eval echo $line)")
    done <<< "$(bash -c declare)"

    send_array "${vars[@]}"
}

function send_args {
    exec 4> "$active_jvm_dir/control"
    send_array "${main_args[@]}" >&4
    send_array "${runtime_args[@]}" >&4
    send_env >&4
    exec 4>&-
}

function wait_for_exit {
    status=$(cat "$active_jvm_dir/status")
#    rm -rf "$active_jvm_dir"
}

function run_main {
    send_args
    $drip_proxy "$active_jvm_dir"

    wait_for_exit
}

function run_drip_command {
    case $drip_command in
        version)
            echo "drip version \"$DRIP_VERSION\"" >&2
            $JAVA_CMD -version;;
        kill)
            kill_jvms "$2";;
        ps)
            jps -vlm | grep org.flatland.drip.Main;;
        upgrade)
            if [[ -z $drip_dir ]]; then
                http_get  "$DRIP_BIN_URL" "$script" || exit $?
                chmod +x "$script"
                rm -rf "$DRIP_SRC" # need to refetch in case it has changed
            elif [[ -d $drip_dir/.git ]]; then
                (cd "$drip_dir" && git pull)
            else
                echo Please use your package manager to upgrade Drip.
                echo For example:
                echo   brew update && brew upgrade drip
            fi
            exit $?;;
        *)
            echo Unknown command: $drip_command
            exit 1;;
    esac
}

# Let's go.

DRIP_POOL=1
DRIP_HOME=${DRIP_HOME:-~/.drip}; mkdir -p "$DRIP_HOME"
DRIP_VERSION=${DRIP_VERSION:-0.0.4}
DRIP_REPO=${DRIP_REPO:-http://clojars.org/repo}
DRIP_JAR_URL=${DRIP_JAR_URL:-$DRIP_REPO/org/flatland/drip/$DRIP_VERSION/drip-$DRIP_VERSION.jar}
DRIP_BIN_URL=${DRIP_BIN_URL:-https://raw.github.com/flatland/drip/master/bin/drip}
DRIP_SRC_URL=${DRIP_SRC_URL:-https://raw.github.com/flatland/drip/master/src}
DRIP_SRC=${DRIP_SRC:-$DRIP_HOME/src}
MVN_REPO=${MVN_REPO:-~/.m2/repository}
JAVA_CMD=${JAVA_CMD:-java}
JAVA_CMD=$(which java)

bootstrap

parse_args "$@"

if [[ -z $drip_command ]]; then
    [[ -z $java_command ]] || exec $JAVA_CMD $java_command
    find_jvm
    run_main

    exit $status
else
    run_drip_command
fi
