#!/usr/bin/env bash

tests=0
passed=0
failed=0

function passed {
    let passed=passed+1
    printf '.'
}

function failed {
    let failed=failed+1
    echo
    echo " $failed) FAILURE in $test"
    stacktrace 1
}

function assert {
    if eval "$@"; then
        passed
    else
        failed
        echo " assertion failed: $@"
    fi
}

function assert_equal {
   if [[ $1 == "$2" ]]; then
       passed
   else
       failed
       echo " expected: $1"
       echo "   actual: $2"
   fi
}

function assert_match {
    if [[ $2 =~ $1 ]]; then
        passed
    else
        failed
        echo " match failed"
        echo " expected =~ $1"
        echo "   actual    $2"
    fi
}

function stacktrace {
  let frame=$1+1

  while caller=$(caller $frame); do
    local line=$(expr "$caller" : '\([0-9]*\)')
    local func=$(expr "$caller" : '[0-9]* \([^ ]*\)')
    local file=$(expr "$caller" : '[0-9]* [^ ]* \([^ ]*\)')
    echo "     $file:$line in $func"
    ((frame++))
  done
}

function test_results {
    echo
    echo "Ran $tests tests containing $((passed + failed)) assertions."
    echo "$failed failures."

    if [[ $failed -ne 0 ]]; then
        echo "Tests failed."
    fi
}

function run_all_tests {
    cd $(dirname $0)
    source ./helpers/init.sh

    local files=()
    while read -r -d '' file; do
        [[ $file =~ \# ]] && continue
        [[ -z $1 || $file == *$1* ]] || break
        files+=("$file")
    done < <(find . \( -name helpers -prune -or -name \*.sh \) -type f -print0)

    for file in "${files[@]}"; do
        local functions=()
        while read -r line; do
            if function=$(expr "$line" : 'function \(test_[^ ]*\) {'); then
                functions+=("$function")
            fi
        done < "$file"

        echo
        printf "%s %s\n" "$0" "$(basename $file .sh)"
        source "$file"

        for f in "${functions[@]}"; do
            let tests=tests+1
            $f
        done
    done

    cd - > /dev/null
}

run_all_tests "$@"
test_results
